#!/usr/bin/python3
# --------------------------------------------------------------------------
# Class definition of SensorsControllerThread - utility functions for the sensors
#
# Author: Benjamin Fuchs
# License: GPL3
#
# Website: https://github.com/benjaminfuchs/who_disposer
#
# --------------------------------------------------------------------------

import time
from threading import Thread

from nclock.Button import Button
from nclock.Sensor import Sensor


class SensorsControllerThread(Thread):
    """ SensorsControllerThread thread """

    INIT_MEASURES = 10
    INIT_TIME = 2
    POLL_INTERVAL = 0.2

    def __init__(self, settings):
        """ Constructor """

        super(SensorsControllerThread, self).__init__(
            name="SensorsControllerThread")
        self._settings = settings
        self._settings.log.msg("SensorsControllerThread: init")
        self._stop_event = settings.stop_event
        self._settings.log.msg(
            "SensorsControllerThread: setting up %s" % settings.get_value('GPIO', 'button'))
        self._button = Button(int(settings.get_value('GPIO', 'button')))
        self._sensor = Sensor(0x70)
        self._state = settings.get('state')
        self._button_long_time = settings.get('button.long_time')
        self._sensor_threshold = settings.get('sensor.threshold')
        self._expected_distance = None
        self._button_count = 0

    def run(self):
        """ run method of thread """

        self._settings.log.msg(
            "SensorsControllerThread: running SensorsControllerThread...")
        if self._state == "starting":
            values = []
            for _ in range(SensorsControllerThread.INIT_MEASURES):
                values.append(self._sensor.distance())
                time.sleep(SensorsControllerThread.INIT_TIME /
                           SensorsControllerThread.INIT_MEASURES)
            self._expected_distance = sum(values) / len(values)
            self._settings.log.msg(
                "SensorsControllerThread: expected distance is %s" % self._expected_distance)
            self._settings.set("state", "running")

        while not self._stop_event.wait(SensorsControllerThread.POLL_INTERVAL):
            self._update_button()
            self._update_sensor()

        self._settings.log.msg("SensorsControllerThread: shutdown")

    def _update_button(self):
        """ check button status """

        name = "button.status"
        old_value = self._settings.get(name)
        if self._button.status():
            if self._button_count <= self._button_long_time / SensorsControllerThread.POLL_INTERVAL:
                value = "short"
                self._button_count += 1
            else:
                value = "long"
        else:
            value = "off"
            self._button_count = 0
        if old_value != value:
            self._settings.set(name, value)

    def _update_sensor(self):
        """ check button status """

        name = "sensor.status"
        old_value = self._settings.get(name)
        distance = self._sensor.distance()
        if distance < (self._expected_distance - self._sensor_threshold) or \
           distance > (self._expected_distance + self._sensor_threshold):
            value = "on"
            self._settings.log.msg("SensorsControllerThread: Hand detected")
        else:
            value = "off"
        if old_value != value:
            self._settings.set(name, value)
