#!/usr/bin/python3
# --------------------------------------------------------------------------
# Class definition of Settings - a value holder class
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import os
import copy
import time
from threading import Thread, Lock, Event

import simplejson

# --- Value holder for shared settings   -----------------------------------


class Settings(object):
    """ Object with shared settings """

    S_TEMP = 0b0001
    S_GLOBAL = 0b0010
    S_ALARMS = 0b0100
    S_RADIO = 0b1000
    S_ALL = S_TEMP | S_GLOBAL | S_ALARMS | S_RADIO

    # initialize object   ----------------------------------------------------

    def __init__(self, parser):
        """ Constructor """

        # public fields
        self.config_parser = parser
        self.debug = self.get_value('GLOBAL', 'debug', '0')
        self.stop_event = Event()

        # private fields
        default_store = os.path.join(os.path.expanduser("~"), "settings.json")
        self._store = self.get_value('GLOBAL', 'store', default_store)
        if self._store != default_store:
            defaults = os.path.join(
                os.path.dirname(self._store), "defaults.json")
        else:
            defaults = os.path.join(os.path.expanduser("~"), "defaults.json")
        self._values = {}
        self._listener = {}
        self._lock = Lock()
        self._savelock = Lock()

        # initialize settings with defaults
        if not os.path.isfile(defaults):
            raise SystemExit("no defaults.json in %s" %
                             os.path.dirname(defaults))
        else:
            self.load(defaults)

    # --- call all listeners for value   --------------------------------------

    def call_listeners(self, name, old_value, value):

        if name in self._listener:
            for listener in self._listener[name]:
                listener(name, old_value, value)

    # --- return all keys+values in a configuration section   ------------------

    def get_values(self, section):
        """ return all key/values of a configuration-section """

        if self.config_parser.has_section(section):
            return self.config_parser.items(section)
        return []

    # --- read a configuration value   -----------------------------------------

    def get_value(self, section, option, default=False):
        """ get value of config-variables and return given default if unset """

        if self.config_parser.has_section(section):
            try:
                value = self.config_parser.get(section, option)
            except:
                if not default:
                    raise SystemExit("no %s in %s" % (option, section))
                value = default
        else:
            value = default
        return value

    # --- convert json-object to settings ------------------------------------

    def set_from_jsonobj(self, obj):

        # convert json-object to settings
        keys = obj.keys()
        for key in keys:
            if not key.startswith('_'):
                if ((key == "led.mode" or key == "display.mode") and
                        obj[key].startswith("mode_")):
                    # compatibility issue
                    obj[key] = obj[key][5:]
                self._values[key] = obj[key]

    # --- load settings   ----------------------------------------------------

    def load(self, store=None):
        if not store:
            store = self._store
        if not os.path.isfile(store):
            if hasattr(self, "log"):
                self.log.msg("file %s does not exist - skipping" % store)
            return
        if hasattr(self, "log"):
            self.log.msg("Loading settings from %s" % store)

        with open(store, "r") as settings_file:
            obj = simplejson.load(settings_file)

            self.set_from_jsonobj(obj)

    # --- serialize settings to json   ---------------------------------------

    def get_jsonobj(self, select=S_GLOBAL | S_ALARMS | S_RADIO):
        jsonobj = {}
        for key in self._values.keys():
            if key.startswith('_'):
                if select & Settings.S_TEMP:
                    jsonobj[key] = self._values[key]
            elif key.startswith('alarm.'):
                if select & Settings.S_ALARMS:
                    jsonobj[key] = self._values[key]
            elif key.startswith('radio.'):
                if select & Settings.S_RADIO:
                    jsonobj[key] = self._values[key]
            else:
                if select & Settings.S_GLOBAL:
                    jsonobj[key] = self._values[key]

        return jsonobj

    # --- save settings   ----------------------------------------------------

    def save(self, wait=True):
        Thread(target=self._save, kwargs=dict(wait=wait)).start()

    def _save(self, wait):
        if self._savelock.acquire(False):
            if wait:
                # we wait a few seconds to collect multiple changes
                delay = 15
                self.log.msg("Saving settings to %s in %d s" %
                             (self._store, delay))
                time.sleep(delay)
            with open(self._store, "w") as settings_file:
                jsonobj = self.get_jsonobj()
                self.log.msg("Saving settings to %s" % self._store)
                simplejson.dump(jsonobj, settings_file, indent=2, sort_keys=True)

            self._savelock.release()
        else:
            self.log.msg(
                "ignoring save-request due to concurrent save in progress")
            # don't do anything - data is probably saved by other thread

    # set a setting   --------------------------------------------------------

    def set(self, name, value, deep=False, notify=True):
        """ set a value """

        old_value = None
        if name in self._values:
            if deep:
                old_value = copy.deepcopy(self._values[name])
            else:
                old_value = self._values[name]

        with self._lock:
            self._values[name] = value
            if not name.startswith('_') and old_value != value:
                self.save()

        if notify:
            self.call_listeners(name, old_value, value)
        return old_value

    # increment a variable   --------------------------------------------------

    def inc(self, name, notify=True):
        """ increment a value """

        value = self.get(name)
        if value is not None:
            if isinstance(value, str):
                value = str(int(value) + 1)
            else:
                value += 1
            return self.set(name, value, notify=notify)
        else:
            return self.set(name, 1, notify=notify)

    # decrement a variable   --------------------------------------------------

    def dec(self, name, notify=True):
        """ decrement a value """

        value = self.get(name)
        if value is not None:
            if isinstance(value, str):
                value = str(int(value) - 1)
            else:
                value -= 1
            return self.set(name, value, notify=notify)
        else:
            return self.set(name, -1, notify=notify)

    # query a setting   -------------------------------------------------------

    def get(self, name, deep=False):
        """ query a value by name """

        if name in self._values:
            if deep:
                return copy.deepcopy(self._values[name])
            return self._values[name]
        return None

    # add settings listener   -------------------------------------------------

    def add_settings_listener(self, name, func):
        """ add a change-listener for attribute name """

        with self._lock:
            if name in self._listener:
                self._listener[name].append(func)
            else:
                self._listener[name] = [func]
